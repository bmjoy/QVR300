<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>Qualcomm&copy; Snapdragon&trade; VR SDK: Configuration</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Qualcomm&copy; Snapdragon&trade; VR SDK
   &#160;<span id="projectnumber">3.0.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">Configuration </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><table class="doxtable">
<tr>
<th>Name </th><th>type </th><th>default </th><th>description  </th></tr>
<tr>
<td>gEyeBufferWidth </td><td>int </td><td>1024 </td><td>Value returned as recommended eye buffer width in <a class="el" href="structsvr_device_info.html" title="Basic device information to allow the client code to optimally setup their simulation and rendering p...">svrDeviceInfo</a>  </td></tr>
<tr>
<td>gEyeBufferHeight </td><td>int </td><td>1024 </td><td>Value returned as recommended eye buffer height in <a class="el" href="structsvr_device_info.html" title="Basic device information to allow the client code to optimally setup their simulation and rendering p...">svrDeviceInfo</a>  </td></tr>
<tr>
<td>gEyeBufferFovX </td><td>float </td><td>90.0f </td><td>Value returned as recommended FOV X in <a class="el" href="structsvr_device_info.html" title="Basic device information to allow the client code to optimally setup their simulation and rendering p...">svrDeviceInfo</a>  </td></tr>
<tr>
<td>gEyeBufferFovY </td><td>float </td><td>90.0f </td><td>Value returned as recommended FOV Y in <a class="el" href="structsvr_device_info.html" title="Basic device information to allow the client code to optimally setup their simulation and rendering p...">svrDeviceInfo</a>  </td></tr>
<tr>
<td>gFrustum_Convergence </td><td>float </td><td>0.0f </td><td>Value returned as recommended eye convergence in <a class="el" href="structsvr_device_info.html" title="Basic device information to allow the client code to optimally setup their simulation and rendering p...">svrDeviceInfo</a>  </td></tr>
<tr>
<td>gFrustum_Pitch </td><td>float </td><td>0.0f </td><td>Value returned as recommended eye pitch in <a class="el" href="structsvr_device_info.html" title="Basic device information to allow the client code to optimally setup their simulation and rendering p...">svrDeviceInfo</a>  </td></tr>
<tr>
<td>gLeftFrustum_Near </td><td>float </td><td>0.0508 </td><td>Value returned as recommended view frustum size in <a class="el" href="structsvr_device_info.html" title="Basic device information to allow the client code to optimally setup their simulation and rendering p...">svrDeviceInfo</a>  </td></tr>
<tr>
<td>gLeftFrustum_Far </td><td>float </td><td>100.0 </td><td>Value returned as recommended view frustum size in <a class="el" href="structsvr_device_info.html" title="Basic device information to allow the client code to optimally setup their simulation and rendering p...">svrDeviceInfo</a>  </td></tr>
<tr>
<td>gLeftFrustum_Left </td><td>float </td><td>-0.031 </td><td>Value returned as recommended view frustum size in <a class="el" href="structsvr_device_info.html" title="Basic device information to allow the client code to optimally setup their simulation and rendering p...">svrDeviceInfo</a>  </td></tr>
<tr>
<td>gLeftFrustum_Right </td><td>float </td><td>0.031 </td><td>Value returned as recommended view frustum size in <a class="el" href="structsvr_device_info.html" title="Basic device information to allow the client code to optimally setup their simulation and rendering p...">svrDeviceInfo</a>  </td></tr>
<tr>
<td>gLeftFrustum_Top </td><td>float </td><td>0.031 </td><td>Value returned as recommended view frustum size in <a class="el" href="structsvr_device_info.html" title="Basic device information to allow the client code to optimally setup their simulation and rendering p...">svrDeviceInfo</a>  </td></tr>
<tr>
<td>gLeftFrustum_Bottom </td><td>float </td><td>-0.031 </td><td>Value returned as recommended view frustum size in <a class="el" href="structsvr_device_info.html" title="Basic device information to allow the client code to optimally setup their simulation and rendering p...">svrDeviceInfo</a>  </td></tr>
<tr>
<td>gRightFrustum_Near </td><td>float </td><td>0.0508 </td><td>Value returned as recommended view frustum size in <a class="el" href="structsvr_device_info.html" title="Basic device information to allow the client code to optimally setup their simulation and rendering p...">svrDeviceInfo</a>  </td></tr>
<tr>
<td>gRightFrustum_Far </td><td>float </td><td>100.0 </td><td>Value returned as recommended view frustum size in <a class="el" href="structsvr_device_info.html" title="Basic device information to allow the client code to optimally setup their simulation and rendering p...">svrDeviceInfo</a>  </td></tr>
<tr>
<td>gRightFrustum_Left </td><td>float </td><td>-0.031 </td><td>Value returned as recommended view frustum size in <a class="el" href="structsvr_device_info.html" title="Basic device information to allow the client code to optimally setup their simulation and rendering p...">svrDeviceInfo</a>  </td></tr>
<tr>
<td>gRightFrustum_Right </td><td>float </td><td>0.031 </td><td>Value returned as recommended view frustum size in <a class="el" href="structsvr_device_info.html" title="Basic device information to allow the client code to optimally setup their simulation and rendering p...">svrDeviceInfo</a>  </td></tr>
<tr>
<td>gRightFrustum_Top </td><td>float </td><td>0.031 </td><td>Value returned as recommended view frustum size in <a class="el" href="structsvr_device_info.html" title="Basic device information to allow the client code to optimally setup their simulation and rendering p...">svrDeviceInfo</a>  </td></tr>
<tr>
<td>gRightFrustum_Bottom </td><td>float </td><td>-0.031 </td><td>Value returned as recommended view frustum size in <a class="el" href="structsvr_device_info.html" title="Basic device information to allow the client code to optimally setup their simulation and rendering p...">svrDeviceInfo</a>  </td></tr>
<tr>
<td>gEnableTimeWarp </td><td>bool </td><td>true </td><td>Override to disable TimeWarp  </td></tr>
<tr>
<td>gDisableReprojection </td><td>bool </td><td>false </td><td>Override to disable reprojection  </td></tr>
<tr>
<td>gDisablePredictedTime </td><td>bool </td><td>false </td><td>Forces svrGetPredictedDisplayTime to return 0.0  </td></tr>
<tr>
<td>gRenderThreadCore </td><td>int </td><td>3 </td><td>Core id to set render thread affinity for (-1 disables affinity), ignored if the QVR Perf module is active.  </td></tr>
<tr>
<td>gEnableRenderThreadFifo </td><td>bool </td><td>false </td><td>Enable/disable setting SCHED_FIFO scheduling policy on the render thread thread, ignored if the QVR Perf module is active.  </td></tr>
<tr>
<td>gForceMinVsync </td><td>int </td><td>0 </td><td>Override for <a class="el" href="structsvr_frame_params.html" title="Per-frame data needed for time warp, distortion/aberration correction. ">svrFrameParams</a> minVsync option (0:override disabled, 1 or 2 forced value)  </td></tr>
<tr>
<td>gUseLinePtr </td><td>bool </td><td>true </td><td>Override for using the linePtr interrupt, if set to false Choreographer will be used instead  </td></tr>
<tr>
<td>gTimeToHalfExposure </td><td>float </td><td>8.33f </td><td>Time (milliseconds) to get to Half Exposure on the display. This usually T/2, but this property can be used to adjust for OLED vs LCD, getting to 3T/4, additional display delay time, etc.  </td></tr>
<tr>
<td>gTimeToMidEyeWarp </td><td>float </td><td>4.16f </td><td>Time (milliseconds) between warping each eye.  </td></tr>
<tr>
<td>gHeuristicPredictedTime </td><td>bool </td><td>false </td><td>Whether to use a heuristic predicted time  </td></tr>
<tr>
<td>gNumHeuristicEntries </td><td>int </td><td>25 </td><td>How many entries to average to get heuristic predicted time  </td></tr>
<tr>
<td>gHeuristicOffset </td><td>float </td><td>0.0 </td><td>Offset added to the heuristic predicted time  </td></tr>
<tr>
<td>gUseQvrPerfModule </td><td>bool </td><td>true </td><td>Enable/disable the QVR Performance module. If active all thread affinities, priorities and HW clocks will be based on the QVR perf module configuration rather than the SDK configuration  </td></tr>
<tr>
<td>gForceCpuLevel </td><td>int </td><td>-1 </td><td>Override to force CPU performance level (-1: app defined, 0:system defined/off, 1/2/3 for min,medium,max)  </td></tr>
<tr>
<td>gCpuLvl1Min </td><td>int </td><td>30 </td><td>Lower CPU frequency (percentage) bound for min performance level, ignored if the QVR Perf module is active.  </td></tr>
<tr>
<td>gCpuLvl1Max </td><td>int </td><td>50 </td><td>Upper CPU frequency (percentage) bound for min performance level, ignored if the QVR Perf module is active.  </td></tr>
<tr>
<td>gCpuLvl2Min </td><td>int </td><td>51 </td><td>Lower CPU frequency (percentage) bound for medium performance level, ignored if the QVR Perf module is active.  </td></tr>
<tr>
<td>gCpuLvl2Max </td><td>int </td><td>80 </td><td>Upper CPU frequency (percentage) bound for medium performance level, ignored if the QVR Perf module is active.  </td></tr>
<tr>
<td>gCpuLvl3Min </td><td>int </td><td>81 </td><td>Lower CPU frequency (percentage) bound for max performance level, ignored if the QVR Perf module is active.  </td></tr>
<tr>
<td>gCpuLvl3Max </td><td>int </td><td>100 </td><td>Upper CPU frequency (percentage) bound for max performance level , ignored if the QVR Perf module is active.  </td></tr>
<tr>
<td>gForceGpuLevel </td><td>int </td><td>-1 </td><td>Override to force GPU performance level (-1: app defined, 0:system defined/off, 1/2/3 for min,medium,max)  </td></tr>
<tr>
<td>gGpuLvl1Min </td><td>int </td><td>30 </td><td>Lower GPU frequency (percentage) bound for min performance level, ignored if the QVR Perf module is active.  </td></tr>
<tr>
<td>gGpuLvl1Max </td><td>int </td><td>50 </td><td>Upper GPU frequency (percentage) bound for min performance level, ignored if the QVR Perf module is active.  </td></tr>
<tr>
<td>gGpuLvl2Min </td><td>int </td><td>51 </td><td>Lower GPU frequency (percentage) bound for medium performance level, ignored if the QVR Perf module is active.  </td></tr>
<tr>
<td>gGpuLvl2Max </td><td>int </td><td>80 </td><td>Upper GPU frequency (percentage) bound for medium performance level, ignored if the QVR Perf module is active.  </td></tr>
<tr>
<td>gGpuLvl3Min </td><td>int </td><td>81 </td><td>Lower GPU frequency (percentage) bound for max performance level, ignored if the QVR Perf module is active.  </td></tr>
<tr>
<td>gGpuLvl3Max </td><td>int </td><td>100 </td><td>Upper GPU frequency (percentage) bound for max performance level, ignored if the QVR Perf module is active.  </td></tr>
<tr>
<td>gForceTrackingMode </td><td>int </td><td>0 </td><td>Force a specific tracking mode 1 = rotational 3 = rotational &amp; positional  </td></tr>
<tr>
<td>gUseMagneticRotationFlag </td><td>bool </td><td>true </td><td>If using roational data only, use version that is magnetically corrected  </td></tr>
<tr>
<td>gLogLinePtrDelay </td><td>float </td><td>0.0 </td><td>Log line ptr delays longer greater than this value (0.0 = disabled)  </td></tr>
<tr>
<td>gLogSubmitFps </td><td>bool </td><td>false </td><td>Enables output of submit FPS to LogCat  </td></tr>
<tr>
<td>gLogPoseVelocity </td><td>bool </td><td>false </td><td>Log out the tracking velocity  </td></tr>
<tr>
<td>gMaxAngVel </td><td>float </td><td>450.0f </td><td>Detected angular velocity larger than this value will be considered an error in the tracking system (degrees / sec)  </td></tr>
<tr>
<td>gMaxLinearVel </td><td>float </td><td>6.0f </td><td>Detected linear/translational velocity larger than this value will be considered an error in the tracking system (meters / sec)  </td></tr>
<tr>
<td>gLogSubmitFrame </td><td>bool </td><td>false </td><td>Log <a class="el" href="svr_api_8h.html#a7b7e7c60e9c42762cb5d111c42c5df0a" title="Submits a frame to asynchronous time warp. ">svrSubmitFrame()</a> parameters  </td></tr>
<tr>
<td>gEnableDebugServer </td><td>bool </td><td>false </td><td>Enables a very basic json-rpc server for interacting with vr while running  </td></tr>
<tr>
<td>gDisableFrameSubmit </td><td>bool </td><td>false </td><td>Debug flag that will prevent the eye buffer render thread from submitted frames to time warp  </td></tr>
<tr>
<td>gControllerService </td><td>char* </td><td>" " </td><td></td></tr>
<tr>
<td>gControllerRingBufferSize </td><td>int </td><td>80 </td><td></td></tr>
<tr>
<td>gSensorEyeOffsetX </td><td>float </td><td>0 </td><td></td></tr>
<tr>
<td>gSensorEyeOffsetY </td><td>float </td><td>0 </td><td></td></tr>
<tr>
<td>gSensorEyeScaleX </td><td>float </td><td>1 </td><td></td></tr>
<tr>
<td>gSensorEyeScaleY </td><td>float </td><td>1 </td><td></td></tr>
<tr>
<td>gDebugServerPort </td><td>int </td><td>8080 </td><td>Port for the debug server to listen for incoming requests on  </td></tr>
<tr>
<td>gLogEvents </td><td>bool </td><td>false </td><td>Enables logcat logging of events  </td></tr>
<tr>
<td>gSensorOrientationCorrectX </td><td>float </td><td>0.0f </td><td>Adjustment if sensors are physically rotated (degrees)  </td></tr>
<tr>
<td>gSensorOrientationCorrectY </td><td>float </td><td>0.0f </td><td>Adjustment if sensors are physically rotated (degrees)  </td></tr>
<tr>
<td>gSensorOrientationCorrectZ </td><td>float </td><td>0.0f </td><td>Adjustment if sensors are physically rotated (degrees)  </td></tr>
<tr>
<td>gSensorHomePosition </td><td>int </td><td>0 </td><td>Base device configuration. 0 = Landscape Left; 1 = Landscape Right  </td></tr>
<tr>
<td>gSensorHeadOffsetX </td><td>float </td><td>0.0f </td><td>Adjustment for device physical distance from head (meters)  </td></tr>
<tr>
<td>gSensorHeadOffsetY </td><td>float </td><td>0.0f </td><td>Adjustment for device physical distance from head (meters)  </td></tr>
<tr>
<td>gSensorHeadOffsetZ </td><td>float </td><td>0.0762 </td><td>Adjustment for device physical distance from head (meters)  </td></tr>
<tr>
<td>gMinPoseQuality </td><td>float </td><td>0.7 </td><td>Minimum pose quality (In range [0.0, 1.0]) allowed  </td></tr>
<tr>
<td>gIMUSensorPoseDelay </td><td>float </td><td>0.0 </td><td>Base IMU delay (milliseconds). How old is pose before it is recorded?  </td></tr>
<tr>
<td>gMaxPredictedTime </td><td>float </td><td>75.0 </td><td>Max allowable predicted pose time (milliseconds)  </td></tr>
<tr>
<td>gLogMaxPredictedTime </td><td>bool </td><td>true </td><td>Enable/disable logging when max predicted time is enforced  </td></tr>
<tr>
<td>gLogRawSensorData </td><td>bool </td><td>false </td><td>Enable/disable logging of sensor values directly from the service  </td></tr>
<tr>
<td>gUseFixedRotation </td><td>bool </td><td>false </td><td>Enable/disable setting of sensor rotation value directly  </td></tr>
<tr>
<td>gFixedRotationQuatX </td><td>float </td><td>0.0f </td><td></td></tr>
<tr>
<td>gFixedRotationQuatY </td><td>float </td><td>0.0f </td><td></td></tr>
<tr>
<td>gFixedRotationQuatZ </td><td>float </td><td>0.0f </td><td></td></tr>
<tr>
<td>gFixedRotationQuatW </td><td>float </td><td>1.0f </td><td></td></tr>
<tr>
<td>gFixedRotationSpeedX </td><td>float </td><td>0.0f </td><td></td></tr>
<tr>
<td>gFixedRotationSpeedY </td><td>float </td><td>0.0f </td><td></td></tr>
<tr>
<td>gFixedRotationSpeedZ </td><td>float </td><td>0.0f </td><td></td></tr>
<tr>
<td>gUseFixedPosition </td><td>bool </td><td>false </td><td>Enable/disable setting of sensor position value directly  </td></tr>
<tr>
<td>gFixedPositionX </td><td>float </td><td>0.0f </td><td></td></tr>
<tr>
<td>gFixedPositionY </td><td>float </td><td>0.0f </td><td></td></tr>
<tr>
<td>gFixedPositionZ </td><td>float </td><td>0.0f </td><td></td></tr>
<tr>
<td>gFixedPositionEndX </td><td>float </td><td>0.0f </td><td></td></tr>
<tr>
<td>gFixedPositionEndY </td><td>float </td><td>0.0f </td><td></td></tr>
<tr>
<td>gFixedPositionEndZ </td><td>float </td><td>0.0f </td><td></td></tr>
<tr>
<td>gFixedPositionSpeed </td><td>float </td><td>0.0f </td><td></td></tr>
<tr>
<td>gEnableMotionVectors </td><td>bool </td><td>false </td><td>Enables motion vector support  </td></tr>
<tr>
<td>gForceAppEnableMotionVectors </td><td>bool </td><td>false </td><td>Force motion vectors for all applications. Otherwise up to application  </td></tr>
<tr>
<td>gEnableYuvDecode </td><td>bool </td><td>true </td><td>For Power: Whether or not to actually send data to motion engine  </td></tr>
<tr>
<td>gUseMotionVectors </td><td>bool </td><td>true </td><td>For Power: Whether or not to use motion data  </td></tr>
<tr>
<td>gWarpMotionVectors </td><td>bool </td><td>true </td><td>Warp current motion engine input to remove head motion  </td></tr>
<tr>
<td>gWarpMotionScale </td><td>float </td><td>1.0f </td><td>Scale of motion vector warping  </td></tr>
<tr>
<td>gLogMotionVectors </td><td>bool </td><td>false </td><td>Enables logging of motion vector activities  </td></tr>
<tr>
<td>gLogThreadState </td><td>bool </td><td>false </td><td>Subject to "gLogMotionVectors": Logs thread activities  </td></tr>
<tr>
<td>gMotionVectorScale </td><td>float </td><td>0.5f </td><td>Scale of eye buffer size to motion vector input  </td></tr>
<tr>
<td>gMotionInterpolationFactor </td><td>float </td><td>0.5f </td><td>Scale of motion vector data applied to interpolated frames (Assume half framerate)  </td></tr>
<tr>
<td>gSmoothMotionVectors </td><td>bool </td><td>true </td><td>Motion data is average of surrounding samples  </td></tr>
<tr>
<td>gSmoothMotionVectorsWithGPU </td><td>bool </td><td>true </td><td>Motion data smoothing is done on the GPU  </td></tr>
<tr>
<td>gRenderMotionVectors </td><td>bool </td><td>false </td><td>Enables display of motion vectors as one of the eye buffers  </td></tr>
<tr>
<td>gRenderMotionInput </td><td>bool </td><td>false </td><td>Enables display of motion input. Current/Previous are the Left/Right eyes (for checking warp). Subject to gRenderMotionVectors  </td></tr>
<tr>
<td>gGenerateBothEyes </td><td>bool </td><td>false </td><td>Generate separate motion data for each eye. Otherwise, same data is used for both  </td></tr>
<tr>
<td>gDisableLensCorrection </td><td>bool </td><td>false </td><td>Override to disable any lens correction during time warp  </td></tr>
<tr>
<td>gDirectModeWarp </td><td>bool </td><td>true </td><td>Override to enable/disable "direct" non-binning mode for time warp rendering  </td></tr>
<tr>
<td>gSingleBufferWindow </td><td>bool </td><td>true </td><td>Override to enable/disable use of single buffer surface for time warp  </td></tr>
<tr>
<td>gTimeWarpThreadCore </td><td>int </td><td>2 </td><td>Core affinity for time warp thread (-1=system defined), ignored if the QVR Perf module is active.  </td></tr>
<tr>
<td>gTimeWarpClearBuffer </td><td>bool </td><td>false </td><td>Enable/disable clearing the time warp surface before rendering  </td></tr>
<tr>
<td>gBusyWait </td><td>bool </td><td>false </td><td>Enable/disable "busy" wait between eyes (on some builds use of nanosleep function can oversleep by as much as 10ms if FIFO isn't set on the sleeping thread)  </td></tr>
<tr>
<td>gEnableWarpThreadFifo </td><td>bool </td><td>true </td><td>Enable/disable setting SCHED_FIFO scheduling policy on the warp thread (must be true if gBusyWait is false to avoid tearing), ignored if the QVR Perf module is active.  </td></tr>
<tr>
<td>gRecenterFrames </td><td>int </td><td>0 </td><td>Number of frames to disable reprojection after sensors are recentered  </td></tr>
<tr>
<td>gSensorInitializeFrames </td><td>int </td><td>0 </td><td>Number of frames to disable display after sensors are started  </td></tr>
<tr>
<td>gTimeWarpMinLoopTime </td><td>int </td><td>0 </td><td>For testing: minimum time (milliseconds) for a timewarp loop. Can be used to simulate timewarp not able to keep up with render. Set to 0 to disable test  </td></tr>
<tr>
<td>gTimeWarpWaitBias </td><td>float </td><td>0.0f </td><td>Bias applied to the time we wait to kick off warping for each eye  </td></tr>
<tr>
<td>gTimeWarpClearColorR </td><td>float </td><td>0.0f </td><td>Fill color for TimeWarp clear (if gTimeWarpClearBuffer enabled)  </td></tr>
<tr>
<td>gTimeWarpClearColorG </td><td>float </td><td>0.0f </td><td>Fill color for TimeWarp clear (if gTimeWarpClearBuffer enabled)  </td></tr>
<tr>
<td>gTimeWarpClearColorB </td><td>float </td><td>0.0f </td><td>Fill color for TimeWarp clear (if gTimeWarpClearBuffer enabled)  </td></tr>
<tr>
<td>gTimeWarpClearColorA </td><td>float </td><td>1.0f </td><td>Fill color for TimeWarp clear (if gTimeWarpClearBuffer enabled)  </td></tr>
<tr>
<td>gTimeWarpEnabledEyeMask </td><td>int </td><td>3 </td><td>svrEyeMask Bit Field: 1 = Left; 2 = Right; 3 = Both  </td></tr>
<tr>
<td>gForceColorSpace </td><td>int </td><td>-1.0f </td><td>Force warp colorspace -1 = app specified, 0 = linear, 1 = sRGB  </td></tr>
<tr>
<td>gApplyDisplaySkew </td><td>bool </td><td>false </td><td>Apply a skew during warp to counteract the impact of display rates  </td></tr>
<tr>
<td>gApplyDisplaySquash </td><td>bool </td><td>false </td><td>Apply a skew during warp to counteract the impact of display rates  </td></tr>
<tr>
<td>gSkewScaleFactor </td><td>float </td><td>1.0f </td><td>Scale factor to apply to the display skewing  </td></tr>
<tr>
<td>gSquashScaleFactor </td><td>float </td><td>1.0f </td><td>Scale factor to apply to the display squash  </td></tr>
<tr>
<td>gCompositeRadius </td><td>float </td><td>0.25f </td><td>Any layer quad outside this range will be composited  </td></tr>
<tr>
<td>gWarpMeshType </td><td>int </td><td>0 </td><td>Warp mesh type: 0 = Columns (Left To Right); 1 = Columns (Right To Left); 2 = Rows (Top To Bottom); 3 = Rows (Bottom To Top)  </td></tr>
<tr>
<td>gWarpMeshRows </td><td>int </td><td>50 </td><td>Number of rows in the warp mesh grid  </td></tr>
<tr>
<td>gWarpMeshCols </td><td>int </td><td>50 </td><td>Number of columns in the warp mesh grid  </td></tr>
<tr>
<td>gLayerMeshRows </td><td>int </td><td>8 </td><td>Number of rows in the layer mesh grid  </td></tr>
<tr>
<td>gLayerMeshCols </td><td>int </td><td>8 </td><td>Number of columns in the layer mesh grid  </td></tr>
<tr>
<td>gWarpEqrMeshRadius </td><td>float </td><td>2.0 </td><td>Radius of warp mesh used for EquiRectangular display (Affects curvature)  </td></tr>
<tr>
<td>gWarpEqrMeshScale </td><td>float </td><td>0.9 </td><td>Amount of screen covered by the EquiRectangular warp mesh  </td></tr>
<tr>
<td>gWarpMeshMinX </td><td>float </td><td>-1.0f </td><td>Screen space coordinate of minimum X-Value  </td></tr>
<tr>
<td>gWarpMeshMaxX </td><td>float </td><td>1.0f </td><td>Screen space coordinate of maximum X-Value  </td></tr>
<tr>
<td>gWarpMeshMinY </td><td>float </td><td>-1.0f </td><td>Screen space coordinate of minimum Y-Value  </td></tr>
<tr>
<td>gWarpMeshMaxY </td><td>float </td><td>1.0f </td><td>Screen space coordinate of maximum Y-Value  </td></tr>
<tr>
<td>gMeshOffsetLeftX </td><td>float </td><td>0.0f </td><td>Screen space adjustment for left mesh to center under lens  </td></tr>
<tr>
<td>gMeshOffsetLeftY </td><td>float </td><td>0.0f </td><td>Screen space adjustment for left mesh to center under lens  </td></tr>
<tr>
<td>gMeshOffsetRightX </td><td>float </td><td>0.0f </td><td>Screen space adjustment for right mesh to center under lens  </td></tr>
<tr>
<td>gMeshOffsetRightY </td><td>float </td><td>0.0f </td><td>Screen space adjustment for right mesh to center under lens  </td></tr>
<tr>
<td>gMeshAspectRatio </td><td>float </td><td>1.0 </td><td>0.0 = Use Screen Size; X.X = Force aspect ratio  </td></tr>
<tr>
<td>gMeshVignette </td><td>bool </td><td>false </td><td>Enable/Disable vignette feature on the warp mesh  </td></tr>
<tr>
<td>gVignetteRadius </td><td>float </td><td>0.7f </td><td>Start radius of vignette feature. Completes at gMeshDiscardUV applied to lens polynomial  </td></tr>
<tr>
<td>gClampBorderEnabled </td><td>bool </td><td>true </td><td>Enable/disable clamp to border color on eye buffers  </td></tr>
<tr>
<td>gClampBorderColorR </td><td>float </td><td>0.0f </td><td>Fill color for clamp to border (if enabled)  </td></tr>
<tr>
<td>gClampBorderColorG </td><td>float </td><td>0.0f </td><td>Fill color for clamp to border (if enabled)  </td></tr>
<tr>
<td>gClampBorderColorB </td><td>float </td><td>0.0f </td><td>Fill color for clamp to border (if enabled)  </td></tr>
<tr>
<td>gClampBorderColorA </td><td>float </td><td>1.0f </td><td>Fill color for clamp to border (if enabled)  </td></tr>
<tr>
<td>gClampBorderOverlayEnabled </td><td>bool </td><td>true </td><td>Enable/disable clamp to border color on overlay buffers  </td></tr>
<tr>
<td>gClampBorderOverlayColorR </td><td>float </td><td>0.0f </td><td>Fill color for clamp to border (if enabled)  </td></tr>
<tr>
<td>gClampBorderOverlayColorG </td><td>float </td><td>0.0f </td><td>Fill color for clamp to border (if enabled)  </td></tr>
<tr>
<td>gClampBorderOverlayColorB </td><td>float </td><td>0.0f </td><td>Fill color for clamp to border (if enabled)  </td></tr>
<tr>
<td>gClampBorderOverlayColorA </td><td>float </td><td>1.0f </td><td>Fill color for clamp to border (if enabled)  </td></tr>
<tr>
<td>gStencilMeshEnabled </td><td>bool </td><td>false </td><td>Enable/disable stencil mesh optimization on eye buffers  </td></tr>
<tr>
<td>gStencilMeshRadius </td><td>float </td><td>0.95f </td><td>Radius of stencil mesh used for eye buffers  </td></tr>
<tr>
<td>gStencilMeshColorR </td><td>float </td><td>0.0f </td><td>Fill color for stencil mesh (if enabled)  </td></tr>
<tr>
<td>gStencilMeshColorG </td><td>float </td><td>0.0f </td><td>Fill color for stencil mesh (if enabled)  </td></tr>
<tr>
<td>gStencilMeshColorB </td><td>float </td><td>0.0f </td><td>Fill color for stencil mesh (if enabled)  </td></tr>
<tr>
<td>gStencilMeshColorA </td><td>float </td><td>1.0f </td><td>Fill color for stencil mesh (if enabled)  </td></tr>
<tr>
<td>gEnableBoundarySystem </td><td>bool </td><td>false </td><td>Enable/disable Boundary display  </td></tr>
<tr>
<td>gForceDisplayBoundarySystem </td><td>bool </td><td>false </td><td>Forces the display of the Boundary display  </td></tr>
<tr>
<td>gLogBoundarySystem </td><td>bool </td><td>false </td><td>Enable/disable loging of Boundary system  </td></tr>
<tr>
<td>gEnableBoundaryMesh </td><td>bool </td><td>false </td><td>Enable/disable Boundary feature using mesh  </td></tr>
<tr>
<td>gBoundaryWarpMeshRows </td><td>int </td><td>2 </td><td>Number of rows in the Boundary mesh  </td></tr>
<tr>
<td>gBoundaryWarpMeshCols </td><td>int </td><td>2 </td><td>Number of cols in the Boundary mesh  </td></tr>
<tr>
<td>gBoundaryZoneMinX </td><td>float </td><td>-4.0 </td><td>Boundary zone size (Real world coordinates in meters)  </td></tr>
<tr>
<td>gBoundaryZoneMaxX </td><td>float </td><td>4.0 </td><td>Boundary zone size (Real world coordinates in meters)  </td></tr>
<tr>
<td>gBoundaryZoneMinY </td><td>float </td><td>-4.0 </td><td>Boundary zone size (Real world coordinates in meters)  </td></tr>
<tr>
<td>gBoundaryZoneMaxY </td><td>float </td><td>4.0 </td><td>Boundary zone size (Real world coordinates in meters)  </td></tr>
<tr>
<td>gBoundaryZoneMinZ </td><td>float </td><td>-4.0 </td><td>Boundary zone size (Real world coordinates in meters)  </td></tr>
<tr>
<td>gBoundaryZoneMaxZ </td><td>float </td><td>4.0 </td><td>Boundary zone size (Real world coordinates in meters)  </td></tr>
<tr>
<td>gBoundaryUVScale </td><td>float </td><td>10.0 </td><td>Boundary zone texture repeat scale (grid spacing)  </td></tr>
<tr>
<td>gBoundaryGridWidth </td><td>float </td><td>0.1 </td><td>Boundary zone grid line width (fractional part of result of gBoundaryUVScale)  </td></tr>
<tr>
<td>gBoundaryVisabilityRadius </td><td>float </td><td>0.5 </td><td>Distance from Boundary zone boundaries when the Boundary mesh starts to be visible  </td></tr>
<tr>
<td>gBoundaryVisabilityScale </td><td>float </td><td>1.5 </td><td>Scale for how quickly the Boundary mesh fades in to full opacity  </td></tr>
<tr>
<td>gBoundaryMeshColorR </td><td>float </td><td>1.0 </td><td>Boundary mesh color  </td></tr>
<tr>
<td>gBoundaryMeshColorG </td><td>float </td><td>1.0 </td><td>Boundary mesh color  </td></tr>
<tr>
<td>gBoundaryMeshColorB </td><td>float </td><td>1.0 </td><td>Boundary mesh color  </td></tr>
<tr>
<td>gBoundaryMeshColorA </td><td>float </td><td>1.0 </td><td>Boundary mesh color  </td></tr>
<tr>
<td>gLensOffsetX </td><td>float </td><td>0.0f </td><td>Horizontal lens offset  </td></tr>
<tr>
<td>gLensOffsetY </td><td>float </td><td>0.0f </td><td>Vertical lens offset  </td></tr>
<tr>
<td>gLensInverse </td><td>bool </td><td>false </td><td></td></tr>
<tr>
<td>gLensPolyK0 </td><td>float </td><td>1.0f </td><td></td></tr>
<tr>
<td>gLensPolyK1 </td><td>float </td><td>0.0f </td><td></td></tr>
<tr>
<td>gLensPolyK2 </td><td>float </td><td>0.22f </td><td></td></tr>
<tr>
<td>gLensPolyK3 </td><td>float </td><td>0.0f </td><td></td></tr>
<tr>
<td>gLensPolyK4 </td><td>float </td><td>0.24f </td><td></td></tr>
<tr>
<td>gLensPolyK5 </td><td>float </td><td>0.0f </td><td></td></tr>
<tr>
<td>gLensPolyK6 </td><td>float </td><td>0.0f </td><td></td></tr>
<tr>
<td>gChromaticPolyK0_R </td><td>float </td><td>0.994f </td><td></td></tr>
<tr>
<td>gChromaticPolyK1_R </td><td>float </td><td>0.0f </td><td></td></tr>
<tr>
<td>gChromaticPolyK2_R </td><td>float </td><td>0.0f </td><td></td></tr>
<tr>
<td>gChromaticPolyK3_R </td><td>float </td><td>0.0f </td><td></td></tr>
<tr>
<td>gChromaticPolyK4_R </td><td>float </td><td>0.0f </td><td></td></tr>
<tr>
<td>gChromaticPolyK5_R </td><td>float </td><td>0.0f </td><td></td></tr>
<tr>
<td>gChromaticPolyK6_R </td><td>float </td><td>0.0f </td><td></td></tr>
<tr>
<td>gChromaticPolyK0_G </td><td>float </td><td>1.003f </td><td></td></tr>
<tr>
<td>gChromaticPolyK1_G </td><td>float </td><td>0.0f </td><td></td></tr>
<tr>
<td>gChromaticPolyK2_G </td><td>float </td><td>0.0f </td><td></td></tr>
<tr>
<td>gChromaticPolyK3_G </td><td>float </td><td>0.0f </td><td></td></tr>
<tr>
<td>gChromaticPolyK4_G </td><td>float </td><td>0.0f </td><td></td></tr>
<tr>
<td>gChromaticPolyK5_G </td><td>float </td><td>0.0f </td><td></td></tr>
<tr>
<td>gChromaticPolyK6_G </td><td>float </td><td>0.0f </td><td></td></tr>
<tr>
<td>gChromaticPolyK0_B </td><td>float </td><td>1.014f </td><td></td></tr>
<tr>
<td>gChromaticPolyK1_B </td><td>float </td><td>0.0f </td><td></td></tr>
<tr>
<td>gChromaticPolyK2_B </td><td>float </td><td>0.0f </td><td></td></tr>
<tr>
<td>gChromaticPolyK3_B </td><td>float </td><td>0.0f </td><td></td></tr>
<tr>
<td>gChromaticPolyK4_B </td><td>float </td><td>0.0f </td><td></td></tr>
<tr>
<td>gChromaticPolyK5_B </td><td>float </td><td>0.0f </td><td></td></tr>
<tr>
<td>gChromaticPolyK6_B </td><td>float </td><td>0.0f </td><td></td></tr>
<tr>
<td>gChromaticPixelBorder </td><td>float </td><td>0.0f </td><td></td></tr>
<tr>
<td>gMeshDiscardUV </td><td>float </td><td>1.0f </td><td>After lens polynomial applied, anything greater than this value will be discarded.  </td></tr>
<tr>
<td>gLogEyeOverSleep </td><td>bool </td><td>false </td><td>Enable/disable checking and logging of oversleep during eye buffer rendering  </td></tr>
<tr>
<td>gLogFrameDoubles </td><td>bool </td><td>false </td><td>Enables output of LogCat messages when TimeWarp frames are reused  </td></tr>
<tr>
<td>gLogMeshCreation </td><td>bool </td><td>false </td><td>Enables output of LogCat messages when meshes are created  </td></tr>
<tr>
<td>gLogVSyncData </td><td>bool </td><td>false </td><td>Enables output of LogCat messages when VSync data is updated  </td></tr>
<tr>
<td>gLogPrediction </td><td>bool </td><td>false </td><td></td></tr>
<tr>
<td>gLogDroppedFrames </td><td>bool </td><td>false </td><td>If next frame warped is not one more than last frame (Application may break this if it assigns wrong frameIndx)  </td></tr>
<tr>
<td>gLogShaderUniforms </td><td>bool </td><td>false </td><td></td></tr>
<tr>
<td>gLogEyeRender </td><td>bool </td><td>false </td><td></td></tr>
<tr>
<td>gMotionToPhotonC </td><td>float </td><td>10.0f </td><td>Scale factor driving intensity of color from angular velocity  </td></tr>
<tr>
<td>gMotionToPhotonAccThreshold </td><td>float </td><td>0.999998f </td><td>Minimum threshold for motion to be considered significant enough to light the display  </td></tr>
</table>
</div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.11
</small></address>
</body>
</html>
