//=============================================================================
// FILE: svrApiTimeWarpShaders.cpp
//                  Copyright (c) 2016 QUALCOMM Technologies Inc.
//                              All Rights Reserved.
//
//==============================================================================
#include <errno.h>
#include <fcntl.h>
#include <poll.h>
#include <sched.h>
#include <string.h>
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/syscall.h>
#include <android/native_window.h>

#include "glm/glm.hpp"
#include "glm/gtc/quaternion.hpp"
#include "glm/gtc/type_ptr.hpp"
#include "glm/gtc/matrix_transform.hpp"
#include "glm/gtx/euler_angles.hpp"
#include "glm/gtx/transform.hpp"

#include "svrCpuTimer.h"
#include "svrGpuTimer.h"
#include "svrGeometry.h"
#include "svrProfile.h"
#include "svrShader.h"
#include "svrUtil.h"
#include "svrConfig.h"

#include "private/svrApiCore.h"
#include "private/svrApiHelper.h"
#include "private/svrApiTimeWarp.h"

using namespace Svr;

// **********************************************
// Debug Blit Shader
// **********************************************
char svrBlitQuadVs[] =
        "#version 300 es\n"
        "in vec4 position;\n"
        "in vec2 texcoord0;\n"
        "layout(location = 1) uniform vec4 posScaleOffset;\n"
        "out vec2 vTexcoord0;\n"
        "void main()\n"
        "{\n"
        "	vTexcoord0 = texcoord0;\n"
        "	// TODO: The W component needs to be passed in.  Currently this breaks rendering if w component used\n"
        "	gl_Position = vec4(position.xy * posScaleOffset.xy + posScaleOffset.zw, position.z, position.w);\n"
        "}\n";  // End of shader string

char svrBlitQuadWarpVs[] =
        "#version 300 es\n"
        "in vec4 position;\n"
        "in vec2 texcoord0;\n"
        "layout(location = 1) uniform vec4 posScaleOffset;\n"
        "layout(location = 2) uniform mat3 transMtx;\n"
        "out vec2 vTexcoord0;\n"
        "void main()\n"
        "{\n"
        "    // Since using a warp matrix, need texture coordinates in [-1, 1]\n"
        "    vec2 newCoord = 2.0 * texcoord0 + vec2(-1.0, -1.0);\n"
        "    vec3 tmpTexCoords = transMtx * vec3(newCoord.xy, 1.0);\n"
        "    vTexcoord0 = 0.5 * tmpTexCoords.xy + vec2(0.5, 0.5);\n"
        "    gl_Position = vec4(position.xy * posScaleOffset.xy + posScaleOffset.zw, position.z, position.w);\n"
        "}\n";  // End of shader string

char svrBlitQuadFs[] =
        "#version 300 es\n"
        "precision highp float;\n"
        "uniform sampler2D srcTex;\n"
        "in vec2 vTexcoord0;\n"
        "out vec4 outColor;\n"
        "void main()\n"
        "{\n"
        "	vec4 srcColor = texture(srcTex, vTexcoord0);\n"
        "	outColor = vec4(srcColor.xyz,srcColor.a);\n"
        "}\n";  // End of shader string

char svrBlitQuadYuvFs[] =
        "#version 300 es\n"
        "\n"
        "#extension GL_EXT_YUV_target : require\n"
        "\n"
        "precision highp float;\n"
        "uniform sampler2D srcTex;\n"
        "in vec2 vTexcoord0;\n"
        "layout (yuv) out vec3 outColor;\n"
        "void main()\n"
        "{\n"
        "	if(vTexcoord0.x < 0.0 || vTexcoord0.x > 1.0 || vTexcoord0.y < 0.0 || vTexcoord0.y > 1.0)\n"
        "	    discard;\n"
        "   // Need to switch row and columns based on how data comes in\n"
        "	// vec4 srcColor = texture(srcTex, vec2(1.0 - vTexcoord0.y, vTexcoord0.x));\n"
        "	vec4 srcColor = texture(srcTex, vTexcoord0);\n"
        "	outColor = vec3(srcColor.xyz);\n"
        "}\n";  // End of shader string

char svrBlitQuadYuvFs_Array[] =
        "#version 300 es\n"
        "\n"
        "#extension GL_EXT_YUV_target : require\n"
        "\n"
        "precision highp float;\n"
        "\n"
        "uniform sampler2DArray srcTex;\n"
        "\n"
        "layout(location = 9) uniform vec4 arrayLayer;\n"
        "\n"
        "in vec2 vTexcoord0;\n"
        "\n"
        "layout (yuv) out vec3 outColor;\n"
        "void main()\n"
        "{\n"
        "	if(vTexcoord0.x < 0.0 || vTexcoord0.x > 1.0 || vTexcoord0.y < 0.0 || vTexcoord0.y > 1.0)\n"
        "	    discard;\n"
        "\n"
        "   vec4 srcColor = texture(srcTex, vec3(vTexcoord0.xy, arrayLayer.x));\n"
        "	outColor = vec3(srcColor.xyz);\n"
        "}\n";  // End of shader string

char svrBlitQuadFs_Image[] =
        "#version 300 es\n"
        "\n"
        "#extension GL_OES_EGL_image_external_essl3 : require\n"
        "\n"
        "precision highp float;\n"
        "uniform samplerExternalOES srcTex;\n"
        "in vec2 vTexcoord0;\n"
        "out vec4 outColor;\n"
        "void main()\n"
        "{\n"
        "	vec4 srcColor = texture(srcTex, vTexcoord0);\n"
        "	outColor = vec4(srcColor.xyz,srcColor.a);\n"
        "}\n";  // End of shader string

char svrBlitQuadYuvFs_Image[] =
        "#version 300 es\n"
        "\n"
        "#extension GL_OES_EGL_image_external_essl3 : require\n"
        "#extension GL_EXT_YUV_target : require\n"
        "\n"
        "precision highp float;\n"
        "uniform samplerExternalOES srcTex;\n"
        "in vec2 vTexcoord0;\n"
        "layout (yuv) out vec3 outColor;\n"
        "void main()\n"
        "{\n"
        "   // Need to switch row and columns based on how data comes in\n"
        "	// vec4 srcColor = texture(srcTex, vec2(1.0 - vTexcoord0.y, vTexcoord0.x));\n"
        "	vec4 srcColor = texture(srcTex, vTexcoord0);\n"
        "	outColor = vec3(srcColor.xyz);\n"
        "}\n";  // End of shader string

// **********************************************
// Stencil Shader
// **********************************************
char svrStencilVs[] =
        "#version 300 es\n"
        "in vec3 position;\n"
        "layout(location = 1) uniform vec4 posScaleOffset;\n"
        "layout(location = 2) uniform vec4 depthValue;\n"
        "void main()\n"
        "{\n"
        "	gl_Position = vec4(position.xy * posScaleOffset.xy + posScaleOffset.zw, depthValue.z, 1.0);\n"
        "}\n";  // End of shader string

char svrStencilArrayVs[] =
        "#version 300 es\n"
        "\n"
        "#extension GL_OVR_multiview : enable\n"
        "#extension GL_OVR_multiview2 : enable\n"
        "#extension GL_OVR_multiview_multisampled_render_to_texture : enable\n"
        "\n"
        "layout(num_views = 2) in;\n"
        "\n"
        "in vec3 position;\n"
        "layout(location = 1) uniform vec4 posScaleOffset;\n"
        "layout(location = 2) uniform vec4 depthValue;\n"
        "void main()\n"
        "{\n"
        "	gl_Position = vec4(position.xy * posScaleOffset.xy + posScaleOffset.zw, depthValue.z, 1.0);\n"
        "}\n";  // End of shader string

char svrStencilFs[] =
        "#version 300 es\n"
        "precision highp float;\n"
        "layout(location = 3) uniform vec4 stencilColor;\n"
        "out vec4 outColor;\n"
        "void main()\n"
        "{\n"
        "	outColor = stencilColor;\n"
        "}\n";  // End of shader string

// **********************************************
// Boundary Mesh Shader
// **********************************************
char svrBoundaryMeshVs[] =
        "#version 300 es\n"
        "\n"
        "in vec3 position;      // Position\n"
        "in vec2 texcoord0;     // Tex Coord\n"
        "\n"
        "layout(location = 1) uniform mat4 projMtx;\n"
        "layout(location = 2) uniform mat4 viewMtx;\n"
        "layout(location = 3) uniform mat4 mdlMtx;\n"
        "\n"
        "out vec2 vTexcoord;\n"
        "\n"
        "\n"
        "//-----------------------------------------------------------------------------\n"
        "void main()\n"
        "//-----------------------------------------------------------------------------\n"
        "{\n"
        "\n"
        "\n"
        "	vTexcoord.xy = texcoord0.xy;\n"
        "	gl_Position = projMtx * (viewMtx * (mdlMtx * vec4(position.xyz, 1.0)));\n"
        "}\n";  // End of shader string

char svrBoundaryMeshArrayVs[] =
        "#version 300 es\n"
        "\n"
        "#extension GL_OVR_multiview : enable\n"
        "#extension GL_OVR_multiview2 : enable\n"
        "#extension GL_OVR_multiview_multisampled_render_to_texture : enable\n"
        "\n"
        "layout(num_views = 2) in;\n"
        "\n"
        "in vec3 position;      // Position\n"
        "in vec2 texcoord0;     // Tex Coord\n"
        "\n"
        "layout(location = 1) uniform mat4 projMtx;\n"
        "layout(location = 2) uniform mat4 viewMtx;\n"
        "layout(location = 3) uniform mat4 mdlMtx;\n"
        "\n"
        "out vec2 vTexcoord;\n"
        "\n"
        "\n"
        "//-----------------------------------------------------------------------------\n"
        "void main()\n"
        "//-----------------------------------------------------------------------------\n"
        "{\n"
        "\n"
        "\n"
        "	vTexcoord.xy = texcoord0.xy;\n"
        "	gl_Position = projMtx * (viewMtx * (mdlMtx * vec4(position.xyz, 1.0)));\n"
        "}\n";  // End of shader string


char svrBoundaryMeshFs[] =
        "#version 300 es\n"
        "\n"
        "layout(location = 4) uniform vec4 BoundaryColor;\n"
        "\n"
        "// X: Width\n"
        "// Y: Not Used\n"
        "// Z: Not Used\n"
        "// W: Not Used\n"
        "layout(location = 5) uniform vec4 BoundaryParams;\n"
        "// uniform sampler2D srcTex;\n"
        "\n"
        "in vec2 vTexcoord; \n"
        "\n"
        "out vec4 outColor;\n"
        "\n"
        "//-----------------------------------------------------------------------------\n"
        "void main()\n"
        "//-----------------------------------------------------------------------------\n"
        "{\n"
        "    // vec4 TexColor = texture(srcTex, vTexcoord.xy);\n"
        "\n"
        "    // vec4 BaseColor = vec4(TexColor.r, TexColor.g, TexColor.b, TexColor.a);\n"
        "    vec4 BaseColor = BoundaryColor;\n"
        "\n"
        "    vec2 fractPart = fract(vTexcoord.xy);\n"
        "    vec2 gridLerp = step(BoundaryParams.x, fractPart);\n"
        "\n"
        "    vec4 clearColor = vec4(0.0, 0.0, 0.0, 0.0);\n"
        "\n"
        "    // Edge can really be anything :)\n"
        "    float lerpValue = step(0.5, gridLerp.x + gridLerp.y);\n"
        "\n"
        "    outColor = mix(clearColor, BoundaryColor, lerpValue);\n"
        "\n"
        "}\n";   // End of shader string

// **********************************************
// Warp Shader - Vertex
// **********************************************
char warpShaderVs[] =
        "\n"
        "// Version, Precision, and conditional compiles will be added above\n"
        "\n"
        "in vec4 position;      // Position\n"
        "in vec4 normal;        // Red\n"
        "in vec4 color;         // Green\n"
        "in vec4 texcoord0;     // Blue\n"
        "\n"
        "layout(location = 1) uniform vec4 posScaleOffset;\n"
        "\n"
        "#ifdef PROJECTION_SUPPORT\n"
        "    layout(location = 2) uniform mat4 textureMtx;\n"
        "#endif     // Projection Support\n"
        "\n"
        "#ifdef UV_SCALE_SUPPORT\n"
        "    layout(location = 4) uniform vec4 uvScaleOffset;\n"
        "#endif     // UV Scale\n"
        "\n"
        "#ifdef SUPPORT_SPHERE_MESH\n"
        "    layout(location = 6) uniform mat4 modelMtx;\n"
        "#endif     // Sphere Mesh Support\n"
        "\n"
        "    layout(location = 10) uniform mat2 skewSquashMatrix;\n"
        "\n"
        "#ifdef SUPPORT_SPHERE_MESH\n"
        "   out vec4 v_WorldPosG;\n"
        "#ifdef CHROMATIC_SUPPORT\n"
        "   out vec4 v_WorldPosR;\n"
        "   out vec4 v_WorldPosB;\n"
        "#endif     // Chromatic Support\n"
        "\n"
        "#else     // Sphere Mesh Support\n"
        "\n"
        "out vec2 vTexcoordG;\n"
        "\n"
        "#ifdef SPACEWARP_SUPPORT\n"
        "out vec2 vSpaceWarpTexCoord;\n"
        "#endif // SPACEWARP_SUPPORT\n"
        "\n"
        "#ifdef CHROMATIC_SUPPORT\n"
        "    out vec2 vTexcoordR;\n"
        "    out vec2 vTexcoordB;\n"
        "#endif     // Chromatic Support\n"
        "\n"
        "#endif     // Sphere Mesh Support\n"
        "\n"
        "#ifdef VIGNETTE_SUPPORT\n"
        "    out vec3 vVignetteFactor;\n"
        "#endif     // Vignette Support\n"
        "\n"
        "//-----------------------------------------------------------------------------\n"
        "void main()\n"
        "//-----------------------------------------------------------------------------\n"
        "{\n"
        "   vec4 tmpTexCoords;\n"
        "#ifdef PROJECTION_SUPPORT\n"
        "	float projIZ;\n"
        "#endif     // Projection Support\n"
        "\n"
        "#ifdef VIGNETTE_SUPPORT\n"
        "#ifdef CHROMATIC_SUPPORT\n"
        "   vVignetteFactor = vec3(color.w, normal.w, texcoord0.w);\n"
        "#else\n"
        "   vVignetteFactor = vec3(color.w, 1.0, 1.0);\n"
        "#endif     // Chromatic Support\n"
        "#endif     // Vignette Support\n"
        "\n"
        "#ifdef SUPPORT_SPHERE_MESH\n"
        "   // Need the world position for the fragment shader\n"
        "	v_WorldPosG = (modelMtx * vec4(color.xyz, 1.0));\n"
        "#ifdef CHROMATIC_SUPPORT\n"
        "	v_WorldPosR = (modelMtx * vec4(normal.xyz, 1.0));\n"
        "	v_WorldPosB = (modelMtx * vec4(texcoord0.xyz, 1.0));\n"
        "#endif     // Chromatic Support\n"
        "#else      // Sphere Mesh Support\n"
        "\n"
        "   // ******************************\n"
        "   // Texture coordinates are projected values\n"
        "   // ******************************\n"
        "   // Green\n"
        "#ifdef PROJECTION_SUPPORT\n"

        "#ifdef AR_DEVICE\n"
        "   tmpTexCoords = vec4((color.x + textureMtx[3][0]) * textureMtx[3][2], color.y + textureMtx[3][1], 0, 0);\n"
        "   tmpTexCoords = textureMtx * tmpTexCoords;\n"
        "   tmpTexCoords.x /= textureMtx[3][2];\n"
        "   tmpTexCoords.x += textureMtx[3][3] * tmpTexCoords.y * 2.0 + 2.0;\n"
        "   tmpTexCoords.x -= 2.0 * tmpTexCoords.y + 2.0 * textureMtx[3][3];\n"
        "   tmpTexCoords.y += textureMtx[2][3];\n"
        "   tmpTexCoords.y -= tmpTexCoords.y * textureMtx[2][3];\n"
        "   vTexcoordG = 0.5 * tmpTexCoords.xy + vec2(0.5, 0.5);\n"
        "   mat2 tmpSquash = skewSquashMatrix;\n"
        "#else //AR_DEVICE\n"
        "   tmpTexCoords = textureMtx * vec4(color.xy, -1.0, 1.0);\n"
        "	projIZ = 1.0 / max( tmpTexCoords.z, 0.00001 );\n"
        "	vTexcoordG = vec2( tmpTexCoords.x * projIZ, tmpTexCoords.y * projIZ );\n"
        "   vTexcoordG.y = vTexcoordG.y - 1.0;\n"
        "   vTexcoordG = vTexcoordG * skewSquashMatrix;\n"
        "   vTexcoordG.y = vTexcoordG.y + 1.0;\n"
        "	vTexcoordG = 0.5 * vTexcoordG + vec2(0.5, 0.5);\n"
        "#endif //AR_DEVICE\n"

        "#else\n"
        "   vTexcoordG.y = vTexcoordG.y - 1.0;\n"
        "   vTexcoordG = vTexcoordG * skewSquashMatrix;\n"
        "   vTexcoordG.y = vTexcoordG.y + 1.0;\n"
        "	vTexcoordG = 0.5 * color.xy + vec2(0.5, 0.5);\n"
        "#endif     // Projection Support\n"
        "\n"
        "#ifdef SPACEWARP_SUPPORT\n"
        "   vSpaceWarpTexCoord = vTexcoordG.xy;\n"
        "#endif // SPACEWARP_SUPPORT\n"
        "\n"
        "#ifdef UV_SCALE_SUPPORT\n"
        "	vTexcoordG = uvScaleOffset.xy * vTexcoordG.xy + uvScaleOffset.zw;\n"
        "\n"
        "#endif // UV_SCALE_SUPPORT\n"
        "\n"
        "#ifdef CHROMATIC_SUPPORT\n"
        "   // Red\n"
        "#ifdef PROJECTION_SUPPORT\n"

        "#ifdef AR_DEVICE\n"
        "   tmpTexCoords = vec4((normal.x + textureMtx[3][0]) * textureMtx[3][2], normal.y + textureMtx[3][1], 0, 0);\n"
        "   tmpTexCoords = textureMtx * tmpTexCoords;\n"
        "   tmpTexCoords.x /= textureMtx[3][2];\n"
        "   tmpTexCoords.x += textureMtx[3][3] * tmpTexCoords.y * 2.0 + 2.0;\n"
        "   tmpTexCoords.x -= 2.0 * tmpTexCoords.y + 2.0 * textureMtx[3][3];\n"
        "   tmpTexCoords.y += textureMtx[2][3];\n"
        "   tmpTexCoords.y -= tmpTexCoords.y * textureMtx[2][3];\n"
        "   vTexcoordR = 0.5 * tmpTexCoords.xy + vec2(0.5, 0.5);\n"
        "#else // AR_DEVICE\n"
        "   tmpTexCoords = textureMtx * vec4(normal.xy, -1.0, 1.0);\n"
        "	projIZ = 1.0 / max( tmpTexCoords.z, 0.00001 );\n"
        "	vTexcoordR = vec2( tmpTexCoords.x * projIZ, tmpTexCoords.y * projIZ );\n"
        "   vTexcoordR.y = vTexcoordR.y - 1.0;\n"
        "   vTexcoordR = vTexcoordR * skewSquashMatrix;\n"
        "   vTexcoordR.y = vTexcoordR.y + 1.0;\n"
        "	vTexcoordR = 0.5 * vTexcoordR + vec2(0.5, 0.5);\n"
        "#endif //AR_DEVICE\n"

        "#else\n"
        "   vTexcoordR.y = vTexcoordR.y - 1.0;\n"
        "   vTexcoordR = vTexcoordR * skewSquashMatrix;\n"
        "   vTexcoordR.y = vTexcoordR.y + 1.0;\n"
        "	vTexcoordR = 0.5 * normal.xy + vec2(0.5, 0.5);\n"
        "#endif     // Projection Support\n"
        "#ifdef UV_SCALE_SUPPORT\n"
        "	vTexcoordR = uvScaleOffset.xy * vTexcoordR.xy + uvScaleOffset.zw;\n"
        "#endif\n"
        "\n"
        "   // Blue\n"
        "#ifdef PROJECTION_SUPPORT\n"

        "#ifdef AR_DEVICE\n"
        "   tmpTexCoords = vec4((texcoord0.x + textureMtx[3][0]) * textureMtx[3][2], texcoord0.y + textureMtx[3][1], 0, 0);\n"
        "   tmpTexCoords = textureMtx * tmpTexCoords;\n"
        "   tmpTexCoords.x /= textureMtx[3][2];\n"
        "   tmpTexCoords.x += textureMtx[3][3] * tmpTexCoords.y * 2.0 + 2.0;\n"
        "   tmpTexCoords.x -= 2.0 * tmpTexCoords.y + 2.0 * textureMtx[3][3];\n"
        "   tmpTexCoords.y += textureMtx[2][3];\n"
        "   tmpTexCoords.y -= tmpTexCoords.y * textureMtx[2][3];\n"
        "   vTexcoordB = 0.5 * tmpTexCoords.xy + vec2(0.5, 0.5);\n"
        "#else // AR_DEVICE\n"
        "   tmpTexCoords = textureMtx * vec4(texcoord0.xy, -1.0, 1.0);\n"
        "	projIZ = 1.0 / max( tmpTexCoords.z, 0.00001 );\n"
        "	vTexcoordB = vec2( tmpTexCoords.x * projIZ, tmpTexCoords.y * projIZ );\n"
        "   vTexcoordB.y = vTexcoordB.y - 1.0;\n"
        "   vTexcoordB = vTexcoordB * skewSquashMatrix;\n"
        "   vTexcoordB.y = vTexcoordB.y + 1.0;\n"
        "	vTexcoordB = 0.5 * vTexcoordB + vec2(0.5, 0.5);\n"
        "#endif //AR_DEVICE\n"

        "#else\n"
        "   vTexcoordB.y = vTexcoordB.y - 1.0;\n"
        "   vTexcoordB = vTexcoordB * skewSquashMatrix;\n"
        "   vTexcoordB.y = vTexcoordB.y + 1.0;\n"
        "	vTexcoordB = 0.5 * texcoord0.xy + vec2(0.5, 0.5);\n"
        "#endif     // Projection Support\n"
        "#ifdef UV_SCALE_SUPPORT\n"
        "	vTexcoordB = uvScaleOffset.xy * vTexcoordB.xy + uvScaleOffset.zw;\n"
        "#endif\n"
        "#endif     // Chromatic\n"
        "\n"
        "#endif     // Sphere Mesh Support\n"
        "\n"
        "gl_Position = vec4(position.xy * posScaleOffset.xy + posScaleOffset.zw, position.z, position.w);\n"
        "}\n";  // End of shader string

// **********************************************
// Warp Shader - Fragment
// **********************************************
char warpShaderFs[] =
        "\n"
        "// Version, Precision, and conditional compiles will be added above\n"
        "\n"
        "#ifdef UV_CLAMP_SUPPORT\n"
        "layout(location = 3) uniform vec4 eyeBorder;\n"
        "#endif\n"
        "\n"
        "#ifdef VIGNETTE_SUPPORT\n"
        "layout(location = 7) uniform vec4 vignetteParams;\n"
        "#endif     // Vignette Support\n"
        "\n"
        "#ifdef SUPPORT_SPHERE_MESH\n"
        "    layout(location = 8) uniform mat4 transformMtx;\n"
        "#endif     // Sphere Mesh Support\n"
        "\n"
        "#ifdef SPACEWARP_GPU_SUPPORT\n"
        "// X: Spacewarp Texture Width\n"
        "// Y: Spacewarp Texture Height\n"
        "// Z: Spacewarp Texture One Pixel Width\n"
        "// W: Spacewarp Texture One Pixel Height\n"
        "layout(location = 11) uniform vec4 spacewarpParams;\n"
        "#endif // Spacewarp GPU Support \n"
        "\n"
        "#ifdef SPACEWARP_SUPPORT\n"
        "layout(location = 12) uniform vec4 spacewarpScaleOffset;\n"
        "#endif // SPACEWARP_SUPPORT \n"
        "\n"
        "#if defined(ARRAY_SUPPORT)\n"
        "   uniform sampler2DArray srcTex;\n"
        "#elif defined(IMAGE_SUPPORT)\n"
        "   uniform samplerExternalOES srcTex;\n"
        "#elif defined(SUPPORT_CUBEMAP)\n"
        "   uniform samplerCube srcTex;\n"
        "#else\n"
        "   uniform sampler2D srcTex;\n"
        "#endif  // Sampler Type\n"
        "\n"
        "#ifdef SPACEWARP_SUPPORT\n"
        "uniform sampler2D spacewarpTex;\n"
        "#endif\n"
        "\n"
        "#ifdef SUPPORT_SPHERE_MESH\n"
        "   in vec4 v_WorldPosG;\n"
        "#ifdef CHROMATIC_SUPPORT\n"
        "   in vec4 v_WorldPosR;\n"
        "   in vec4 v_WorldPosB;\n"
        "#endif     // Chromatic Support\n"
        "\n"
        "#else     // Sphere Mesh Support\n"
        "\n"
        "in vec2 vTexcoordG; \n"
        "\n"
        "#ifdef SPACEWARP_SUPPORT\n"
        "in vec2 vSpaceWarpTexCoord;\n"
        "#endif // SPACEWARP_SUPPORT\n"
        "\n"
        "#ifdef CHROMATIC_SUPPORT\n"
        "in vec2 vTexcoordR;\n"
        "in vec2 vTexcoordB;\n"
        "\n"
        "#endif\n"
        "#endif     // Sphere Mesh Support\n"
        "\n"
        "#ifdef ARRAY_SUPPORT\n"
        "layout(location = 9) uniform vec4 arrayLayer;\n"
        "#endif\n"
        "\n"
        "#ifdef VIGNETTE_SUPPORT\n"
        "in vec3 vVignetteFactor;\n"
        "#endif     // Vignette Support\n"
        "\n"
        "out vec4 outColor;\n"
        "\n"
        "#ifdef SUPPORT_EQUIRECTANGULAR\n"
        "//--------------------------------------------------------------------------------------\n"
        "vec2 FragGetEquiRectCoord(vec3 WorldVector)\n"
        "//--------------------------------------------------------------------------------------\n"
        "{\n"
        "    // U - Based on XZ (atan is [-pi, pi])\n"
        "    float UValue = atan(WorldVector.x, WorldVector.z) / 3.14159265358979323846;\n"
        "    UValue = UValue * 0.5 + 0.5;\n"
        "\n"
        "    // V - Based on Y (asin is [-pi/2, pi/2] => [-1,1] => [0, 1])\n"
        "    float VValue = 2.0 * asin(WorldVector.y) / 3.14159265358979323846;\n"
        "    VValue = VValue * 0.5 + 0.5;\n"
        "\n"
        "    return vec2(1.0 - UValue, VValue);\n"
        "}\n"
        "#endif // Equirectangular\n"
        "\n"
        "//-----------------------------------------------------------------------------\n"
        "void main()\n"
        "//-----------------------------------------------------------------------------\n"
        "{\n"
        "#ifdef SUPPORT_SPHERE_MESH\n"
        "    // First, figure out texture UV Coordinates\n"
        "    vec3 normalizedPosG = normalize(v_WorldPosG.xyz);\n"
        "    #ifdef SUPPORT_EQUIRECTANGULAR\n"
        "        vec2 eqrCoordG = FragGetEquiRectCoord(normalizedPosG.xyz);\n"
        "        vec4 xformCoordG = transformMtx * vec4(eqrCoordG.xy, 0.0, 1.0);\n"
        "        #ifdef  ARRAY_SUPPORT\n"
        "            vec4 TexColorG = texture(srcTex, vec3(xformCoordG.xy, arrayLayer.x));\n"
        "        #else\n"
        "            vec4 TexColorG = texture(srcTex, xformCoordG.xy);\n"
        "        #endif // Array Support\n"
        "    #elif defined(SUPPORT_CUBEMAP)\n"
        "        vec4 xformCoordG = transformMtx * vec4(normalizedPosG.xyz, 1.0);\n"
        "        vec4 TexColorG = textureLod(srcTex, xformCoordG.xyz, 1.0);\n"
        "    #endif // Equirectangular|Cube Support\n"
        "    \n"
        "   #ifdef CHROMATIC_SUPPORT\n"
        "       vec3 normalizedPosR = normalize(v_WorldPosR.xyz);\n"
        "       #ifdef SUPPORT_EQUIRECTANGULAR\n"
        "           vec2 eqrCoordR = FragGetEquiRectCoord(normalizedPosR.xyz);\n"
        "           vec4 xformCoordR = transformMtx * vec4(eqrCoordR.xy, 0.0, 1.0);\n"
        "           #ifdef  ARRAY_SUPPORT\n"
        "               vec4 TexColorR = texture(srcTex, vec3(xformCoordR.xy, arrayLayer.x));\n"
        "           #else\n"
        "               vec4 TexColorR = texture(srcTex, xformCoordR.xy);\n"
        "           #endif // Array Support\n"
        "       #elif defined(SUPPORT_CUBEMAP)\n"
        "           vec4 xformCoordR = transformMtx * vec4(normalizedPosR.xyz, 1.0);\n"
        "           vec4 TexColorR = textureLod(srcTex, xformCoordR.xyz, 1.0);\n"
        "       #endif // Equirectangular|Cube Support\n"
        "       \n"
        "       vec3 normalizedPosB = normalize(v_WorldPosB.xyz);\n"
        "       #ifdef SUPPORT_EQUIRECTANGULAR\n"
        "           vec2 eqrCoordB = FragGetEquiRectCoord(normalizedPosB.xyz);\n"
        "           vec4 xformCoordB = transformMtx * vec4(eqrCoordB.xy, 0.0, 1.0);\n"
        "           #ifdef  ARRAY_SUPPORT\n"
        "               vec4 TexColorB = texture(srcTex, vec3(xformCoordB.xy, arrayLayer.x));\n"
        "           #else\n"
        "               vec4 TexColorB = texture(srcTex, xformCoordB.xy);\n"
        "           #endif // Array Support\n"
        "       #elif defined(SUPPORT_CUBEMAP)\n"
        "           vec4 xformCoordB = transformMtx * vec4(normalizedPosB.xyz, 1.0);\n"
        "           vec4 TexColorB = textureLod(srcTex, xformCoordB.xyz, 1.0);\n"
        "       #endif // Equirectangular|Cube Support\n"
        "   #endif // Chromatic Support\n"
        "   \n"
        "   #ifdef CHROMATIC_SUPPORT\n"
        "       vec4 BaseColor = vec4(TexColorR.r, TexColorG.g, TexColorB.b, TexColorG.a);\n"
        "   #else\n"
        "       vec4 BaseColor = vec4(TexColorG.r, TexColorG.g, TexColorG.b, TexColorG.a);\n"
        "   #endif\n"
        "   \n"
        "       outColor = BaseColor;\n"
        "   \n"
        "   #else     // SUPPORT_SPHERE_MESH\n"
        "   \n"
        "    vec2 localTexcoordG = vTexcoordG.xy; \n"
        "#ifdef CHROMATIC_SUPPORT\n"
        "    vec2 localTexcoordR = vTexcoordR.xy; \n"
        "    vec2 localTexcoordB = vTexcoordB.xy; \n"
        "#endif\n"
        "\n"
        "#ifdef SPACEWARP_SUPPORT\n"
        "    // Need to offset the texture coordinates by the spacewarp values.\n"
        "    vec2 spacewarpCoord = spacewarpScaleOffset.xy * vSpaceWarpTexCoord.xy + spacewarpScaleOffset.zw;\n"
        "\n"
        "    vec4 spacewarpOffset = texture(spacewarpTex, spacewarpCoord.xy);\n"
        "\n"
        "#ifdef SPACEWARP_GPU_SUPPORT\n"
        "    // Read surrounding values and average them\n"
        "    spacewarpOffset += texture(spacewarpTex, spacewarpCoord.xy + vec2(spacewarpParams.z, 0.0f));\n"
        "    spacewarpOffset += texture(spacewarpTex, spacewarpCoord.xy + vec2(-spacewarpParams.z, 0.0f));\n"
        "    spacewarpOffset += texture(spacewarpTex, spacewarpCoord.xy + vec2(0.0f, spacewarpParams.w));\n"
        "    spacewarpOffset += texture(spacewarpTex, spacewarpCoord.xy + vec2(0.0f, -spacewarpParams.w));\n"
        "    spacewarpOffset /= vec4(5.0f, 5.0f, 5.0, 5.0);\n"
        "#endif // SPACEWARP_GPU_SUPPORT \n"
        "\n"
        "    localTexcoordG.xy -= spacewarpOffset.xy;\n"
        "#ifdef CHROMATIC_SUPPORT\n"
        "    localTexcoordR.xy -= spacewarpOffset.xy;\n"
        "    localTexcoordB.xy -= spacewarpOffset.xy;\n"
        "#endif\n"
        "#endif // SPACEWARP_SUPPORT \n"
        "\n"
        "   #ifdef UV_CLAMP_SUPPORT\n"
        "    vec4 TexColorG = texture(srcTex, vec2( clamp( localTexcoordG.x, eyeBorder.x, eyeBorder.y), localTexcoordG.y));\n"
        "   #else\n"
        "#ifdef  ARRAY_SUPPORT\n"
        "    vec4 TexColorG = texture(srcTex, vec3(localTexcoordG.xy, arrayLayer.x));\n"
        "   #else\n"
        "    vec4 TexColorG = texture(srcTex, localTexcoordG.xy);\n"
        "   #endif\n"
        "   #endif\n"
        "   \n"
        "   #ifdef CHROMATIC_SUPPORT\n"
        "   #ifdef UV_CLAMP_SUPPORT\n"
        "    vec4 TexColorR = texture(srcTex, vec2( clamp( localTexcoordR.x, eyeBorder.x, eyeBorder.y), localTexcoordR.y));\n"
        "    vec4 TexColorB = texture(srcTex, vec2( clamp( localTexcoordB.x, eyeBorder.x, eyeBorder.y), localTexcoordB.y));\n"
        "   #else\n"
        "#ifdef  ARRAY_SUPPORT\n"
        "    vec4 TexColorR = texture(srcTex, vec3(localTexcoordR.xy, arrayLayer.x));\n"
        "    vec4 TexColorB = texture(srcTex, vec3(localTexcoordB.xy, arrayLayer.x));\n"
        "   #else\n"
        "    vec4 TexColorR = texture(srcTex, localTexcoordR.xy);\n"
        "    vec4 TexColorB = texture(srcTex, localTexcoordB.xy);\n"
        "   #endif\n"
        "   #endif\n"
        "   \n"
        "   #endif\n"
        "   \n"
        "       // Combine the colors to get final results\n"
        "   #ifdef CHROMATIC_SUPPORT\n"
        "       vec4 BaseColor = vec4(TexColorR.r, TexColorG.g, TexColorB.b, TexColorG.a);\n"
        "   #else\n"
        "       vec4 BaseColor = vec4(TexColorG.r, TexColorG.g, TexColorG.b, TexColorG.a);\n"
        "   #endif\n"
        "   \n"
        "   outColor = BaseColor;\n"
        "   \n"
        "#endif     // if/else SUPPORT_SPHERE_MESH\n"
        "\n"
        "#ifdef VIGNETTE_SUPPORT\n"
        "    // Vignette Data: [Start Radius, End Radius, Radius Delta, Not Used]\n"
        "    vec3 lerpVal = vVignetteFactor.xyz - vec3(vignetteParams.x, vignetteParams.x, vignetteParams.x);\n"
        "    lerpVal /= vec3(vignetteParams.z, vignetteParams.z, vignetteParams.z);\n"
        "    lerpVal = clamp(lerpVal, 0.0, 1.0);\n"
        "    lerpVal = vec3(1.0, 1.0, 1.0) - lerpVal;\n"
        "    outColor.xyz *= lerpVal.xyz;\n"
        "#endif     // Vignette Support\n"
        "}\n"
        "\n";   // End of shader string

